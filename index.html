<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genesis Mobile Miner</title>
    <!-- Carrega Tailwind CSS para estiliza√ß√£o moderna e mobile-first -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f0f4f8; }
        .card { background-color: white; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
        .balance-display { transition: all 0.5s ease; }
        .mining-btn-active { animation: pulse-green 1.5s infinite; }
        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
        }
        /* Corrigido para mostrar o erro em vermelho vivo */
        .error-box { background-color: #fee2e2; border: 1px solid #dc2626; color: #dc2626; padding: 10px; border-radius: 8px; margin-top: 10px; font-weight: bold; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-xl mx-auto">
        <h1 class="text-3xl font-bold text-center text-green-600 mb-6">
            üîë Genesis Mobile Miner (GEN)
        </h1>

        <!-- SE√á√ÉO DE SALDO E STATUS -->
        <div class="card p-6 mb-6">
            <h2 class="text-lg font-semibold text-gray-700 mb-3">Seu Saldo Total</h2>
            <div id="balance-display" class="balance-display text-5xl font-extrabold text-center py-4 rounded-lg bg-gray-50 text-red-600">
                0.0 GEN
            </div>
            <p class="text-sm text-gray-500 text-center mt-2">ID do Minerador: <span id="user-id" class="font-mono text-xs text-gray-400">...</span></p>
            <p class="text-sm text-gray-500 text-center mt-1">√öltimo Bloco da Rede: <span id="latest-block-id" class="font-semibold">0</span></p>
        </div>

        <!-- SE√á√ÉO DE MINERA√á√ÉO -->
        <div class="card p-6 mb-6">
            <h2 class="text-lg font-semibold text-gray-700 mb-3">Minera√ß√£o PoQ</h2>
            <p id="mining-status" class="text-center font-medium mb-4 text-yellow-600">Conectando ao Firebase...</p>
            <button id="mining-toggle-btn" onclick="toggleMining()" disabled
                class="w-full py-3 text-white font-bold rounded-xl transition duration-300 bg-gray-400 hover:bg-gray-500">
                Aguarde a Conex√£o
            </button>
            <div id="mining-progress" class="text-sm text-gray-500 mt-3 text-center">Tentativas: 0</div>
            <div id="error-message" class="error-box hidden"></div>
        </div>

        <!-- SE√á√ÉO DE BLOCOS DA REDE -->
        <div class="card p-6">
            <h2 class="text-lg font-semibold text-gray-700 mb-3">Blocos da Blockchain</h2>
            <div id="block-list" class="space-y-2 max-h-40 overflow-y-scroll">
                <p class="text-sm text-gray-500">Carregando blocos...</p>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            query, 
            orderBy, 
            limit, 
            onSnapshot, 
            doc, 
            getDoc,
            setDoc,
            serverTimestamp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Importando Crypto-JS para a fun√ß√£o de hashing SHA-256
        import * as crypto from 'https://unpkg.com/crypto-js@4.1.1/index.js';

        // --- VARI√ÅVEIS GLOBAIS FIREBASE (MANDAT√ìRIO) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // Usamos um objeto vazio como fallback seguro
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let app, auth, db, userId;
        let isAuthReady = false;

        // --- ESTADO GLOBAL DA MINERA√á√ÉO ---
        let isMining = false;
        let latestBlock = null; 
        let currentBalance = 0.0;
        let miningInterval = null; 
        
        const COLLECTION_PATH = `artifacts/${appId}/public/data/blocks`;
        const GENESIS_ID = '0'; // Documento ID para o bloco 0 - Deve ser uma string no Firestore
        
        const UI = {
            balanceDisplay: document.getElementById('balance-display'),
            userId: document.getElementById('user-id'),
            latestBlockId: document.getElementById('latest-block-id'),
            miningStatus: document.getElementById('mining-status'),
            miningToggleBtn: document.getElementById('mining-toggle-btn'),
            miningProgress: document.getElementById('mining-progress'),
            blockList: document.getElementById('block-list'),
            errorMessage: document.getElementById('error-message')
        };

        // --- FUN√á√ïES DE INICIALIZA√á√ÉO FIREBASE E AUTENTICA√á√ÉO ---

        async function initializeFirebase() {
            try {
                UI.miningStatus.textContent = '1. Inicializando Servi√ßos...';
                
                if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
                    throw new Error("Configura√ß√£o do Firebase ausente ou incompleta. Falha de ambiente.");
                }
                
                // Initialize Firebase
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // 1. Autentica√ß√£o 
                UI.miningStatus.textContent = '2. Autenticando Usu√°rio...';
                let userCredential;

                if (initialAuthToken) {
                    userCredential = await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    userCredential = await signInAnonymously(auth);
                }
                
                if (userCredential && userCredential.user) {
                    userId = userCredential.user.uid;
                    UI.userId.textContent = userId;
                    isAuthReady = true;
                    console.log("Firebase e Autentica√ß√£o prontos. User ID:", userId);
                    
                    UI.miningStatus.textContent = '3. Conectado ao DB. Configurando Chain...';
                    
                    // 2. Inicializa√ß√£o do G√™nese e Listener do DB
                    await setupGenesisBlockAndListener();
                    
                    // Se chegou at√© aqui, a carteira est√° pronta
                    stopMining(); 
                    
                } else {
                    throw new Error("Falha ao obter credenciais de usu√°rio ap√≥s o login.");
                }

            } catch (error) {
                console.error("Erro ao inicializar Firebase:", error);
                UI.miningStatus.textContent = `‚ùå Erro: ${error.message.substring(0, 50)}...`;
                UI.miningToggleBtn.textContent = 'Falha Cr√≠tica';
                UI.miningToggleBtn.disabled = true;
                showError(`Falha na Inicializa√ß√£o (Etapa 1-2): ${error.message}`);
            }
        }
        
        function showError(message) {
            UI.errorMessage.textContent = message;
            UI.errorMessage.classList.remove('hidden');
        }

        // --- L√ìGICA CORE DE BLOCKCHAIN (HASH & POQ) ---

        /**
         * Gera o hash SHA-256 do bloco.
         */
        function hashBlock(data) {
            const kSecreta = data.PROVA_K_SECRETA || '';
            const nDiff = data.N_DIFF || '10000'; 
            
            const dataStr = `${data.ID_BLOCO}-${data.NOME_MOEDA}-${data.DATA_CRIACAO}-${nDiff}-${data.HASH_ANTERIOR}-${data.TRANSACOES}-${kSecreta}`;
            
            const hash = crypto.SHA256(dataStr).toString(crypto.enc.Hex);
            
            return hash.substring(0, 12);
        }

        /**
         * Executa o Proof-of-Quotient (PoQ) em um loop n√£o-bloqueante.
         */
        function minePoQ(nDiff, prevHash) {
            return new Promise((resolve) => {
                
                let targetMultiplier;
                try {
                    const hashPart = prevHash.substring(0, 7);
                    targetMultiplier = parseInt(hashPart, 16) % 9999999 + 1000000; 
                } catch (e) {
                    targetMultiplier = 7654321; 
                }

                const minK = 1000;
                const maxK = 9999999;
                
                let kSecreta = -1;
                let tentativas = 0;
                
                function runSearch() {
                    if (!isMining) {
                         resolve(null);
                         return;
                    }
                    const batchSize = 500000; 
                    let startK = minK + tentativas;
                    let endK = Math.min(startK + batchSize, maxK);

                    for (let k = startK; k <= endK; k++) {
                        tentativas++;
                        
                        const rAlvo = targetMultiplier * k;
                        const resto = rAlvo % nDiff;
                        
                        if (resto === 0) {
                            kSecreta = k;
                            break;
                        }
                    }
                    
                    if (kSecreta !== -1) {
                        resolve({ kSecreta, tentativas });
                    } else if (endK < maxK) {
                        UI.miningProgress.textContent = `Tentativas: ${tentativas.toLocaleString()}`;
                        // Continuar a busca no pr√≥ximo tick do evento loop
                        setTimeout(runSearch, 0); 
                    } else {
                        // Se atingir o limite, resetar e tentar de novo, ou parar
                        resolve(null); 
                    }
                }
                
                runSearch();
            });
        }
        
        /**
         * Cria um novo bloco e o salva no Firestore.
         */
        async function createAndSaveBlock(latest) {
            if (!userId || !latest) return;

            const novoId = latest.ID_BLOCO + 1;
            const nDiff = latest.N_DIFF; 
            const prevHash = latest.HASH_BLOCO_ATUAL;

            UI.miningStatus.textContent = `‚öôÔ∏è Minerando o Bloco ${novoId} (Base: ${prevHash.substring(0, 4)}...)`;
            UI.miningToggleBtn.disabled = true;

            const resultadoMineracao = await minePoQ(nDiff, prevHash);
            
            if (!resultadoMineracao) {
                UI.miningStatus.textContent = "‚ùå Minera√ß√£o parada ou falhou (Tentativa de K esgotada).";
                UI.miningToggleBtn.disabled = false;
                return;
            }

            const { kSecreta, tentativas } = resultadoMineracao;
            const recompensa = 5.0; 
            
            const novoBlocoDados = {
                ID_BLOCO: novoId,
                NOME_MOEDA: 'GEN',
                DATA_CRIACAO: new Date().toISOString(),
                RECOMPENSA_MINERACAO: recompensa.toFixed(1),
                N_DIFF: nDiff,
                HASH_ANTERIOR: prevHash,
                TRANSACOES: `Recompensa: ${recompensa.toFixed(1)} GEN para Minerador_01 (UserID: ${userId})`,
                PROVA_K_SECRETA: kSecreta,
                MINERADOR_ID: userId,
                tentativas: tentativas,
                timestamp: serverTimestamp() 
            };

            const hashFinal = hashBlock(novoBlocoDados);
            novoBlocoDados.HASH_BLOCO_ATUAL = hashFinal;

            try {
                // Tenta salvar no Firestore
                // O ID do documento √© o ID_BLOCO (string)
                await setDoc(doc(db, COLLECTION_PATH, String(novoId)), novoBlocoDados);

                console.log(`‚úÖ Bloco ${novoId} criado e salvo. Hash: ${hashFinal}`);
                UI.miningStatus.textContent = `‚ú® Bloco ${novoId} Minerado! Pr√≥xima rodada em 1s...`;
                UI.miningProgress.textContent = `Tentativas: 0`;

            } catch (e) {
                console.error("Erro ao salvar bloco no Firestore:", e);
                UI.miningStatus.textContent = `‚ùå Erro ao salvar Bloco ${novoId}.`;
                showError(`Erro DB (Salvar): ${e.message}`);
            } finally {
                UI.miningToggleBtn.disabled = false;
            }
        }
        
        /**
         * Loop que controla a minera√ß√£o cont√≠nua.
         */
        async function miningLoop() {
            if (!isMining || !latestBlock || latestBlock.ID_BLOCO < 0) {
                stopMining();
                return;
            }
            
            await createAndSaveBlock(latestBlock);
            
            miningInterval = setTimeout(miningLoop, 1000); 
        }

        // --- FUN√á√ïES DE INTERFACE E CONTROLE ---
        
        window.toggleMining = function() {
            if (!isAuthReady) {
                showError("Aguarde a conex√£o com o Firebase ser estabelecida (Etapa 1-3).");
                return;
            }

            if (isMining) {
                stopMining();
            } else {
                startMining();
            }
        }
        
        function startMining() {
            if (isMining) return;
            isMining = true;
            UI.miningToggleBtn.textContent = "üõë PARAR MINERA√á√ÉO";
            UI.miningToggleBtn.classList.add('mining-btn-active', 'bg-red-500', 'hover:bg-red-600');
            UI.miningToggleBtn.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-gray-400', 'hover:bg-gray-500');
            
            miningLoop(); 
        }

        function stopMining() {
            isMining = false;
            clearTimeout(miningInterval);
            UI.miningToggleBtn.textContent = "‚ñ∂Ô∏è INICIAR MINERA√á√ÉO";
            UI.miningToggleBtn.classList.remove('mining-btn-active', 'bg-red-500', 'hover:bg-red-600', 'bg-gray-400', 'hover:bg-gray-500');
            UI.miningToggleBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            UI.miningStatus.textContent = "Pausado. Clique para recome√ßar.";
            UI.miningToggleBtn.disabled = false;
        }
        
        function updateBalanceUI() {
            const colorClass = currentBalance > 0 ? 'text-green-600' : 'text-red-600';
            UI.balanceDisplay.textContent = `${currentBalance.toFixed(1)} GEN`;
            UI.balanceDisplay.className = `balance-display text-5xl font-extrabold text-center py-4 rounded-lg bg-gray-50 ${colorClass}`;
        }
        
        function renderBlockList(blocks) {
            UI.blockList.innerHTML = '';
            
            if (blocks.length === 0) {
                UI.blockList.innerHTML = '<p class="text-sm text-gray-500">Nenhum bloco encontrado na Blockchain.</p>';
            }

            blocks.reverse().forEach(block => {
                const isGenesis = block.ID_BLOCO === 0;
                const isMine = block.MINERADOR_ID === userId;
                const statusColor = isMine ? 'text-blue-600' : 'text-gray-500';
                
                let dataCriacao = 'N/A';
                try {
                     const date = block.timestamp && block.timestamp.toDate ? block.timestamp.toDate() : new Date(block.DATA_CRIACAO);
                     dataCriacao = date.toLocaleTimeString('pt-BR');
                } catch {}

                UI.blockList.innerHTML += `
                    <div class="p-3 border rounded-lg ${isMine ? 'border-blue-200 bg-blue-50' : 'border-gray-200 bg-white'}">
                        <p class="font-semibold ${statusColor}">
                            ${isGenesis ? 'G√™nese' : `ID ${block.ID_BLOCO}`} | ${dataCriacao}
                        </p>
                        <p class="text-xs text-gray-600 mt-1">
                            Recompensa: <span class="font-bold text-green-700">${block.RECOMPENSA_MINERACAO || '0.0'} GEN</span>
                            <span class="${statusColor}">(${isMine ? 'Seu Bloco' : 'Outro Minerador'})</span>
                            <br>Hash: <span class="font-mono text-xs">${block.HASH_BLOCO_ATUAL || '...'}</span>
                        </p>
                    </div>
                `;
            });
        }


        // --- CONFIGURA√á√ÉO DA BLOCKCHAIN E LISTENER DE SALDO ---

        async function setupGenesisBlockAndListener() {
            // 1. Verificar G√™nese
            // Usando GENESIS_ID como string ('0')
            const genesisRef = doc(db, COLLECTION_PATH, GENESIS_ID);
            
            try {
                const genesisSnap = await getDoc(genesisRef);

                // Cria o Bloco G√™nese se n√£o existir
                if (!genesisSnap.exists()) {
                    console.log("Bloco G√™nese n√£o encontrado. Inicializando...");
                    const genesisBlock = {
                        ID_BLOCO: 0,
                        NOME_MOEDA: 'GEN',
                        DATA_CRIACAO: new Date().toISOString(),
                        RECOMPENSA_MINERACAO: '0.0', 
                        N_DIFF: 10000,
                        HASH_ANTERIOR: '000000000000', 
                        TRANSACOES: 'Genesis Block - Genesis Mobile Coin Chain Initialization',
                        PROVA_K_SECRETA: 0, 
                        MINERADOR_ID: 'SYSTEM',
                        timestamp: serverTimestamp(), 
                        HASH_BLOCO_ATUAL: '000000000000' 
                    };
                    
                    genesisBlock.HASH_BLOCO_ATUAL = hashBlock(genesisBlock);
                    await setDoc(genesisRef, genesisBlock);
                }

                // 2. Configurar Listener de Blocos (Em tempo real)
                // Ordenar por 'timestamp'
                const q = query(collection(db, COLLECTION_PATH), orderBy("timestamp", "desc"), limit(100)); 
                
                onSnapshot(q, (snapshot) => {
                    let tempBalance = 0.0;
                    let latestBlockId = -1;
                    let blocks = [];
                    let latestBlockData = null;

                    snapshot.docs.forEach(d => {
                        const data = d.data();
                        const idBloco = data.ID_BLOCO;
                        
                        if (idBloco > latestBlockId) {
                            latestBlockId = idBloco;
                            latestBlockData = data;
                        }

                        if (data.MINERADOR_ID === userId) {
                            tempBalance += parseFloat(data.RECOMPENSA_MINERACAO || 0.0);
                        }
                        
                        blocks.push(data);
                    });
                    
                    if (latestBlockId === -1 && blocks.length > 0) {
                        latestBlockId = blocks[0].ID_BLOCO;
                        latestBlockData = blocks[0];
                    }
                    
                    latestBlock = latestBlockData;
                    currentBalance = tempBalance;
                    
                    UI.latestBlockId.textContent = latestBlockId;
                    updateBalanceUI();
                    renderBlockList(blocks);
                    
                    if (!isMining) {
                        stopMining(); 
                    }
                    
                    UI.miningStatus.textContent = latestBlockId >= 0 ? "Pronto para Minerarrr! ‚õèÔ∏è" : "Aguardando Bloco G√™nese...";
                    // Limpa a lista de blocos se ainda estiver mostrando a mensagem de carregamento.
                    if(latestBlockId >= 0) {
                         UI.blockList.querySelector('p').remove();
                    }

                }, (error) => {
                    console.error("Erro no listener do Firestore:", error);
                    showError("Erro de Conex√£o DB (Listener): Verifique o console. Pode ser falta de permiss√£o ou √≠ndice ausente.");
                });
            } catch (error) {
                 console.error("Erro na fase de G√™nese/Listener:", error);
                 showError(`Falha na Configura√ß√£o da Chain (Etapa 3): ${error.message}.`);
            }
        }

        // --- IN√çCIO ---
        initializeFirebase();

    </script>
</body>
</html>

